


<!doctype html>
<html lang="en">
  <head>
    <script type="text/javascript" src="https://livejs.com/live.js"></script>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="course.css" type="text/css">

    
    <style>
    /* CSS for bootstrap4 popover colouring */
    .popover {background: #dae7f1;}
    .popover-header {background: #6c9dc6; }

    .jumbotron-head{
        background:linear-gradient(rgba(0, 0, 250, 0.15), rgba(125, 250, 250, 0.55)),url(img/nanopore_head.png);
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-position: top right;
        color:black !important;
    }
	</style>


    <title>Third Generation Sequencing - A Case Study</title>
  </head>
  <body>
      <div class="jumbotron vertical-center jumbotron-fluid jumbotron-head">
        <div class="container">
          <h1 class="display-4">Nanopore Sequencing <br> Practical </h1>
          <p class="lead">An applied tutorial covering third generation sequence analysis</p>
        </div> <!-- Container -->
      </div>

      <div class="container">












        <!-- LSHTM PATHOGEN GENOMICS COURSE TO BE REMOVED!!! -->
        <div class="alert alert-warning">
          <b>
            Please run the following code to get the practical data:
          </b>
          <pre><code>bash <(curl -kSs https://tbdr.lshtm.ac.uk/static/get_nanopore_data.sh) </pre></code>
        </div>
















	<h4>Nanopore Sequencing lecture</h4><br>
    <object data="presentations/nanopore_lecture.pdf#page=1" type="application/pdf" width="100%" height="700px">
        <p><b>Example fallback content</b>: This browser does not support PDFs. Please download the PDF to view it:
        <a href="presentations/nanopore_lecture.pdf">Download PDF</a>.</p>
    </object>
        <hr>
	<h4>Nanopore Sequencing Practical</h4><br>
      	<br>

        <h4>Introduction</h4>
        <p>In this session we are going to be looking at data generated by third-generation nanopore sequencing technology. Developed by Oxford Nanopore Technologies (ONT), these platforms, rather than the next-generation 'sequencing-by-synthesis approach', make use of an array of microscopic protein pores set in in an electrically resistant membrane which guide strands of DNA or RNA through them. Each nanopore corresponds to its own electrode connected to a channel and sensor chip, which measures the electric current that flows through the nanopore. When a molecule passes through a nanopore, the current is disrupted to produce a ‘squiggle’. The squiggle is then decoded using basecalling algorithms to determine the DNA or RNA sequence in real time. Oxford Nanopore’s most popular platform is the MinION which is capable of generating single reads of up to <a href="https://ib.bioninja.com.au/_Media/genome-size-table_med.jpeg" target="_blank" style="color: #0881c2">2.3 Mb</a> (2.3 million bases).</p>

        <img src="img/sequencing_animation.gif" class="img-fluid" alt="Responsive image">

        <p> The MinION is one of 5 scalable platforms developed by ONT. High-throughput applications such as the GridION and PromethION use an array of nanopore flowcells to produce between 5 to 48 times more data than the MinION alone – outputting up to 48 TB of data in one run. More downscaled solutions such as The Flongle and SmidgION use a smaller, single flowcell to generate data. The MinION is a highly portable sequencing platform, about the size of a large USB flash drive. This technology enables researchers to perform sequencing experiments almost anywhere, providing they have the correct equipment to prepare the DNA libraries and analyse the output data. <p>

        <img src="img/picture_2.jpg" class="img-fluid" alt="Responsive image">

        <p>A complete sequencing run on the MinION platform can generate 100s of gigabytes of data, and downstream analyses require a significant amount of high-performance compute (HPC) resources – multicore processors and greater availability of RAM. This poses a significant logistical challenge for researchers who want to take advantage of the platform’s portability, in that the availability of HPC or a high-speed internet connection is essential. Over recent years, the integration of <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit" target="_blank" style="color: #0881c2">GPUs</a> (graphics processing units) in to analysis workflows has accelerated the basecalling process. A typlical nanopore sequencing workflow is detailed in the below diagram.<p>

        <img src="img/pipeline_diagram.png" class="img-fluid" alt="Responsive image">

        <h4>Library preperation and sequencing reagents</h4>
        <p>As explained in the lecture at the start of the session, there are numerous considerations to make when choosing a library preparation kit suitable for your sequencing experiment. For this dataset, the <a href="https://test.store.nanoporetech.com/native-barcoding-kit-24.html" target="_blank" style="color: #0881c2">NBD 112.24</a> kit was used. This kit utilises the newer <a href="https://nanoporetech.com/q20plus-chemistry" target="_blank" style="color: #0881c2">‘Kit 12’ chemistry</a>, which yields reads of a higher average quality score (Q20+) when compared to its predecessors, such as the <a href="https://store.nanoporetech.com/uk/ligation-sequencing-kit.html" target="_blank" style="color: #0881c2">LSK 109</a> kit. The NBD 112.24 kit also allows for the multiplexing of 24 samples through the ligation of barcode oligonucleotide sequences to each strand of genomic DNA in a given sample. To generate the dataset featured in this activity, we purified 200 ng of genomic TB DNA from culture and followed the kit instructions as per manufacturer’s instruction. The sequencing run was performed on the MinION with an <a href="https://store.nanoporetech.com/uk/flow-cell-r10-4.html" target="_blank" style="color: #0881c2">R10.4 flow cell</a> .  <p>

        <img src="img/multiplex_diagram.png" class="img-fluid" alt="Responsive image">
        <h4>Activity Briefing</h4>
        <p>For this session, we will be working with data generated by both the next-generation Illumina (short-read) and third-generation ONT (long-read) platforms. In combining these two formats of sequencing technologies, we can build a hybrid assembly which makes use of the longer but more error-prone reads of ONT platforms to build a contiguous chromosomal scaffold and the shorter less erroneous reads of Illumina platforms for error correction. <p>

        <p>The data we will use is <p>

          <img src="img/activity_diagram.png" class="img-fluid" alt="Responsive image">


        <br>
        <h4>Basecalling</h4>

        

        <p>To convert the raw data output produced by the MinION sequencing run in to a usable form we need to perform a process called basecalling. This converts the raw electronic signal which is collected as the DNA passes through the pore, in to base reads – A, C, T or G. To do this we will use a program called Guppy – a software package designed by ONT which uses <a href="https://en.wikipedia.org/wiki/Recurrent_neural_network" target="_blank" style="color: #0881c2">recurrent neural nets (RNN)</a> to interpret the raw signal, which comes in a proprietary '.fast5' format file produced by the sequencer software and convert it in to the standard .fastq format, for use downstream in our pipeline. Users also have the choice of using the experimental <a href="https://github.com/nanoporetech/bonito" target="_blank" style="color: #0881c2">Bonito</a> basecaller which gives the option of training specialised models for specific basecalling applications. As mentioned above, GPUs are used to accelerate the basecalling process. Without a GPU performing basecalling becomes a very slow process, therfore it is advised that users procure a machine with a compatable Nvidia GPU <a href="https://esr-nz.github.io/gpu_basecalling_testing/gpu_benchmarking.html" target="_blank" style="color: #0881c2">(more information on this here)</a>. <p>

        <div class="row">
          <div class="col-sm">
             <img src="img/basecalling.gif" class="img-fluid" alt="Responsive image" style="width: 20vw">
          </div>
          
          <div class="col-sm">
            <img src="img/gpu_diagram.png" class="img-fluid" alt="Responsive image" style="width: 20vw">
          </div>
        </div>
        
        

        <p><strong>Activate the conda environment for this activity, navigate to the <i>cd ~/data/nanopore_activity_tb/nanopore_reads</i> folder in the home directory, and we’ll start the first step.</strong><p>

        <pre>conda activate nanopore_tb</pre>

        <pre><code>cd ~/data/nanopore_activity_tb/nanopore_reads</pre></code>


        <div class="alert alert-warning">
          <p>Use the <kbd>ls</kbd> command to see what is inside this folder. Use <kbd>head</kbd> to preview one of the <i>fast5</i> files. As you might find, it's completely unreadable. This is becuase at this stage, the data is in a binary format representing the <i>squiggle</i> signal we spoke about previously. We need to basecall this data before we can use it.</p>
        </div>

        <p> Basecalling can be performed in a number of ways. There is an option to perform this while sequencing in the <a href="https://nanoporetech.com/nanopore-sequencing-data-analysis" target="_blank" style="color: #0881c2">MinKNOW GUI package</a>, however this software provides fewer options in the ways basecalling can be completed and is less powerful. Here, we will use Guppy for maximum flexibility. Since the machines we are working on do not have a GPU available we will have to use the two CPU cores available to us. Therefore, we will only basecall a subset (<1%) of the dataset as an example, and in the subsequent steps we will use a pre-basecalled output</p>





        <p><strong>Hover over the different elements of the basecalling command to see its function:</strong><p>


        <pre><code><a href="#" title="guppy_basecaller" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This is first command to call the main guppy executable.">guppy_basecaller</a> <a href="#" title="Basecalling configuration file" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This is the pre-trained model used for basecalling.<br><b>dna_r10.4_e8.1_fast.cfg</b> is the model we will use in this case. However there are numerous models available depending on the flowcell used and the sequencing chemistry of the kit. <b>dna_r10.4</b> designates that we are using DNA basecalling with the R10.4 flowcell. <b>e8.1</b> denotes the motor protein used for sequencing. This is unique to each kit used, so be sure to chose the correct one. <b>fast</b> denotes the complexity of the basecalling model to be used. The options are usually <b>fast</b>, <b>hac<b/> (high accuracy) or <b>sup</b> (super-high accuracy), the latter two of which are only suitable for machines with GPU resources.">--config dna_r10.4_e8.1_fast.cfg</a> <a href="#" title="--barcode_kits" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller which barcoding kit was used in the library preperation. This allows the basecaller to search for the specific barcode sequences assigned to each sample, and seperate them for downstream analysis">--barcode_kits SQK-NBD112-24</a> <a href="#" title="--trim_adapters" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller to automatically remove the sequencing adapter sequences.">--trim_adapters</a> <a href="#" title="--compress_fastq " data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller to compress the outputted fastq files so that they consume less disk space.">--compress_fastq </a> <a href="#" title=">--input_path" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller where to find the raw fat5 files">--input_path ~/data/nanopore_activity_tb/nanopore_reads </a> <a href="#" title="--save_path" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller where to save the compressed fastq output files">--save_path ~/data/nanopore_activity_tb/nanopore_reads/processing/fast_guppy_out </a></code></pre>

        <p> You should now see the bascalling process begin, and a progress bar appear. This may take some time depending on the performance of your machine.<p>

        <img src="img/basecall_1.png" class="img-fluid" alt="Responsive image">

        <p><strong>When the process in completed, you will find the basecalled reads in .fastq formatted files. Navigate to the output directory by typing the following in to the terminal: </strong> <p>


        <pre><code>cd ~/data/nanopore_activity_tb/nanopore_reads/processing/fast_guppy_out/pass</pre></code>

        <div class="alert alert-warning">
          <p>Use the <kbd>ls</kbd> command to see what is inside this folder. This directory holds folders corresponding to each barcode discovered in the demultiplexing process which, in turn, contain the demutiplexed bascalled fastq read files. Use <kbd> <a href="#" title="zcat" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="zcat is used in the same way as the cat command, except it is capabale of opening gzip compressed files">zcat</a> | head</kbd> to preview one of the compresssed <i>fastq</i> files. Unlike the fast5 files, these are human-readable and contain all of the read data required for downstream analyses. Can you identify any of the common elements of a .fastq format files - similar to the ones you may have encountered in previous sessions? Click <a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" style="color: #0881c2">here</a> to find out more about the FASTQ format.</p>
        </div>
        <div class="alert alert-warning">
          As we see from the <kbd>guppy_basecaller</kbd> command, there are numerous parameters for the basecalling model, particularly, the <b>fast</b> (fast low-accuracy), <b>hac</b> (high-accuracy) and <b>sup</b> (super-high accuracy) variants, each requiring increasing compute resources respectively. Using a more complex model will increase the read quality and decrease the error rate in the sequencing reads. To illustrate the differences in read quality between the models, I have applied the <b>fast</b> and <b>sup</b> models, as well as duplex basecalling and plotted the scores. Click the <a href="./concat_qualscores.html" target="_blank" style="color: #0881c2">link</a> to load the plots.
        </div>

      <h4>Question 1</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>Which model produces the highest quality reads?</strong></div>
          <div class="card-header" id="headingOne" data-toggle="collapse" data-target="#collapseOne">
                  dna_r10.4_e8.1_fast.cfg
            </div>
            <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: You can find the right answer by hovering over the model name in the full <kbd>guppy_basecaller</kbd> command above.
              </div>
            </div>
                <div class="card-header" id="headingTwo" data-toggle="collapse" data-target="#collapseTwo">
                  dna_r10.4_e8.1_sup.cfg
            </div>
            <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>

        <br>

 <h4>Basecalling - Quality Control</h4>


        <p>Before moving on to the analysis steps, it is important to assess the quality of the sequencing output. This helps us understand how successful our sequencing run has been. There are numerous factors which dictate the quality of the output data, spanning between quality of the input material, library preparation to software and hardware failure. We will look at some important metrics produced by the sequencer which will give us a feel for how well the run went.<p>

        <p>In order to get the run metrics in to a useful form, we will use an <a href="https://tleonardi.github.io/pycoQC/" target="_blank" style="color: #0881c2">pycoQC</a> to produce a range of plots in a HTML output, which we will use to judge the quality of the sequencing run. Something to note, is that in this activity we will only use a small subset of the sequenced reads, or else the analysis would take all day. This subsetting means that the sequencing telemetry may look inconsistent, when compared to a full run. We will use the data corresponding to barcode08 moving forward<p>

        <p><b>Navigate to the folder containing the demultiplexed barcode08 reads</b>/p>

        <pre><code>cd ~/data/nanopore_activity_tb/nanopore_reads/processing/fast_guppy_out/pass/barcode08</pre></code>

        <p>In this folder we can see numerous compressed fastq.gz files. Let's join them all together to make it easier for us to analyse them by using <kbd>zcat</kbd> and gzip to recompress them afterward. The reads will be outputted to the qc folder in the root of the activity folder for the next step</p>

        <pre><code>zcat *.fastq.gz | gzip > ~/data/nanopore_activity_tb/qc/barcode08_reads.fastq.gz </pre></code>
        <p>Navigate to the qc folder</p>
        <pre><code>cd ~/data/nanopore_activity_tb/qc/ </pre></code>

        <p> Firstly, to run pycoQC we need an alignment so that we can obtain coverage statistics. For this, we will use an alternative to the <i>BWA-mem</i> alignment algorithm called <a href="https://github.com/lh3/minimap2" target="_blank" style="color: #0881c2">minimap2</a>. The usage of minimap2 is identical to that of BWA, so hopefully you should be familiar with the syntax. </p>

         <pre><code> minimap2 -ax map-ont ~/data/nanopore_activity_tb/ref/tb_ref.fasta barcode08_reads.fastq.gz | samtools view -S -b - | samtools sort - -o barcode08_mapping.sorted.bam; samtools index barcode08_mapping.sorted.bam</code></pre>

         <p>Now that the alignment is compete, we can build the QC report.</p>

       <pre><code>pycoQC -f ~/data/nanopore_activity_tb/nanopore_reads/processing/fast_guppy_out/.sequencing_summary.txt -a ~/data/nanopore_activity_tb/qc/barcode08_mapping.sorted.bam -o pycoqc_barcode_08_results.html</pre></code>

       <div class="alert alert-primary">
          After executing the command you should find the output called 'pycoqc_barcode_08_results.html'. Open them up in the file manager or in the terminal (with the below command) and inspect some of the plots and see what you can find out about our sequencing run. Discuss with the people around you what you think the plots might indicate.
        </div>

        <pre><code>firefox pycoqc_barcode_08_results.html</pre></code>

        <p>Before continuing, quit the browser by clicking the X in the top right corner of the web-browser window.<p>


       <br>
        <h4>Question 2</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>What is the average <a href="#" title="depth" data-toggle="popover" data-trigger="hover" data-placement="top"  data-content="Mapped read depth refers to the total number of bases sequenced and aligned at a given reference base position">depth</a> of barcode08 reads on the TB reference genome?</strong></div>
          <div class="card-header" id="headingOne" data-toggle="collapse" data-target="#collapseOne">
                  10.6X
            </div>
            <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: You can find the answer in the plot at the bottom of the pycoQC summary.
              </div>
            </div>
                <div class="card-header" id="headingTwo" data-toggle="collapse" data-target="#collapseTwo">
                  25.58X
            </div>
            <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>
        <br>

        <br>
        <h4>Question 3</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>What is the <a href="#" title="N50" data-toggle="popover" data-trigger="hover" data-placement="top"  data-content="N50 can be described as a weighted median statistic such that 50% of the entire assembly is contained in contigs or scaffolds equal to or larger than this value.">N50</a> of the <b>passed reads (>Q7)</b> for all basecalled reads in this run?</strong></div>
          <div class="card-header" id="headingThree" data-toggle="collapse" data-target="#collapseThree">
                N50= 966 bp
            </div>
            <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
                <div class="card-header" id="headingFour" data-toggle="collapse" data-target="#collapseFour">
                 N50= 1309 bp
            </div>
            <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>Wrong. Try looking at the table at the top of the pycoQC report. Be sure to find the 'Passed' read section.</strong>
              </div>
            </div>
          </div>
        </div>
        <br>
        <h4>Adapter Trimming</h4>

        <p>Nanopore library preparation results in the addition of a sequencing adapter at each end of the fragment. Both the template and complement strands to be sequenced carry the motor protein which means both strands are able to translocate the nanopore. For downstream analysis, it is important to remove these adapters. For this we will use <a href="https://github.com/rrwick/Porechop" target="_blank" style="color: #0881c2">Porechop</a>. This program processes all of the reads in our basecalled fastq file, and removes these adapter sequences. Furthermore, the ligation library prep process can result in conjoined reads, meaning an adapter will be found in the middle of an extra-long read. Porechop will identify these, split them and remove the adapters. In addition, if you use a multiplexing kit to maximise sample throughput, this program will split the reads based on the molecular barcode added to each sample. Our dataset only has one sample, so this demultiplexing won't be necessary. </p>
        <br>
        <p><strong>Let's launch porechop and remove the adapters from the basecalled fastq file:</strong></p>
        <br>
        <pre><code>porechop -i ~/data/nanopore_activity_tb/qc/barcode08_reads.fastq.gz -o ~/data/nanopore_activity_tb/qc/barcode08_reads.porechop.fastq.gz</pre></code>
        <br>
        <h4>Kraken QC</h4>

        <p>Another method of quality control is to check our reads for sequence contamination from other 'off-target' organisms using taxanomic read assignment tools such as <a href="https://ccb.jhu.edu/software/kraken/" target="_blank" style="color: #0881c2">Kraken</a> or <a href="https://ccb.jhu.edu/software/centrifuge/" target="_blank" style="color: #0881c2">Centrifuge</a>. This is important in order to firstly, understand how effective your DNA extraction, enrichment and sequencing was. And secondly, to prevent anomalous reads from being incorporated in to assemblies.</p>
        <p>Using our basecalled reads we will perform an analysis using Kraken. Kraken is a tool which sifts through each read in a .fastq file and crosschecks it against a database of reads from assigned organisms. The output is a taxonomic assignment of each read, enabling the identification and quantification of any contamination. In this case we will be looking for any reads which do not belong to the TB reference genome.</p>

        <p><strong>Let’s navigate to the kraken folder to begin the analysis:</strong></p>


        <pre><code>cd ~/data/nanopore_activity_tb/qc</pre></code>

        <p>The following line of code is composed of these elements:<p>
        <p>Kraken – calling the Kraken executable<p>
        <p>kraken --db ~/data/nanopore_activity/kraken/KDB/ - this points kraken to a vast sequence database of relevant microorganisms to cross-check our reads against<p>
        <p>--output temp.krak – this argument locates the output file<p>
        <p>~/data/nanopore_activity_tb/qc/barcode08_reads.fastq.gz – this argument locates the input file
        </p>

        <p><strong>Type the following command in to the terminal to unleash the Kraken:</strong></s></p>

        <pre><code>kraken --db ~/data/nanopore_activity/kraken/KDB/ --output taxa.krak ~/data/nanopore_activity_tb/qc/barcode08_reads.porechop.fastq.gz </pre></code>

        <img src="img/kraken_1.png" class="img-fluid" alt="Responsive image">



        <p>This file isn't particularly easy to interpret, you can take a look by typing <kbd>head taxa.kraken</kbd>. So, we will use a program called <a href="https://github.com/khyox/recentrifuge" target="_blank" style="color: #0881c2">Recentrifuge</a> to transform these data in to a more human-readable format.</p>

        <pre><code>rcf -k temp.krak -o taxa.kraken</pre></code>

        <p>Try opening the HTML file generated by recentrifuge in a web browser, what can you tell about the sequencing run? Was is successful? Note - due to constraints with the virtual machine, we have generated an alternative report, which can be loaded using the below command. Copy and paste it in to the terminal. If you have any questions about this, ask a demonstrator.</p>

	       <pre><code>firefox taxa.kraken.rcf.html</pre></code>

        <p>Our reads look nicely pure, we can see the majority of the reads are from the MTB complex. We can confirm this further by checking the alignment we built earlier for the pycoQC step. Try using <kbd>samtools flagstat barcode08_mapping.sorted.bam </kbd> to generate a report for the alignment. Does this agree with the Kraken results? </p>


        <br>
        <h4>Question 4</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>Can you see any contaminating reads? What organism(s) is/are there? What percentage of reads were mapped to the TB genome?</strong></div>
          <div class="card-header" id="headingFive" data-toggle="collapse" data-target="#collapseFive">
                  <i>85.9% </i>
            </div>
            <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: Try using <kbd>samtools flagstat</kbd> to find the percentage of reads mapped.
              </div>
            </div>
                <div class="card-header" id="headingSix" data-toggle="collapse" data-target="#collapseSix">
                  <i>99.60%</i>
            </div>
            <div id="collapseSix" class="collapse" aria-labelledby="headingSix" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>
        <br>

        <h4>Alignment Visualisation</h4>

        <p>Now that we have verified a successful sequencing run, our basecalled and trimmed TB read data are ready to go, we will visulise our mapped alignment using Tablet. 

        <pre><code>tablet</pre></code>

        <p>Using the below animation as a guide, open up tablet and load the sorted.bam and the reference.fasta files, then click on the ‘contig’ in the pane on the left side of the screen. You will see a loading bar, then the alignment will be shown. In the left ‘contig’ pane you will fine some metrics associated with this dataset. </p>

        <div><img src="img/tablet.gif" class="img-fluid" alt="Responsive image"></div>

        <br>

        <div class="alert alert-warning">
          Note the ‘mismatch’ column in the left hand pane. This metric describes the percentage of bases which do not ‘agree’ with the reference file sequence.
        </div>
          <br>
          <br>

          <p>Try bringing up some of the reads you have worked with in previous session. Remember to select the appropriate ‘sorted’ .bam file and the correct reference fasta. Does anything strike you about the contrasting features of the data sets? Scrolling downwards in the alignment viewer on Tablet, what do you notice about the ‘structures’ formed by the reads?</p>
        

        <div class="alert alert-warning">
         Using Tablet, we can also visualise the differences between the fast and the sup basecalling models we have used today.
        </div>

        <br>
        <h4>Question 4</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>What is the percentage of the bases which are mismatched?</strong></div>
          <div class="card-header" id="headingSeven" data-toggle="collapse" data-target="#collapseSeven">
                  <i>17.2%</i>
            </div>
            <div id="collapseSeven" class="collapse" aria-labelledby="headingSeven" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: Check again in the 'contig' pane on the left hand side of the screen
              </div>
            </div>
                <div class="card-header" id="headingS" data-toggle="collapse" data-target="#collapseEight">
                  <i>2.1% </i>
            </div>
            <div id="collapseEight" class="collapse" aria-labelledby="headingEight" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>
        <br>
        <br>
        <br>


        <p><strong>One of the foremost caveats of nanopore sequencing is the high error rate. It is important that we use programs which are sensitive to that - which is why we used the 'ont2d' argument in the mapping stage. Try switching the colour scheme to ‘Variants’ by using the tab in the top left corner of the interface.</strong> </p>

        <br>

        <div><img src="img/tablet_2.gif" class="img-fluid" alt="Responsive image"></div>

        <br>

        <p>You can take a closer look at the individual bases by zooming in, either by using the sliding bar on the ‘Home’ tab at the top of the screen or by using ‘Ctrl’+Mouse Scroll. The red squares in the ‘Variants’ view represent the mismatched reads. </p>

        <div class="alert alert-primary">
          An important aspect of an effective nanopore sequencing analysis is being able to differentiate between errors or low quality basecalls, and true SNPs. You can see that there are random errors dotted around the screen, like static on a TV. Do you notice that some positions in the alignment have a distinct vertical column of red squares. These are most likely the variants we are looking for, and the key to unlocking our sequence data. These columns represent positions which have a high frequency of basecalls which do not agree with the reference sequence.  It is unlikely that random errors will appear in such a manner, and so, in our next analysis we will use these high frequency variants to alter the reference sequence to build a new sequence, in a process called ‘variant calling’.
        </div>

        <br>
        <br>
        <h4>Assembly</h4>
        
        <p>As we have covered in the previous session, denovo assembly techniques can be used to build genome sequences by piecing together a set of reads to form a set of <a href="#" data-toggle="popover" data-trigger="hover" title="contig" data-html="true" data-content="<img src='img/contig.png' width='200' />">contigs</a>, or in the best case, a whole-chromosome assembly. Luckily, with TB, we only have one chromosome to assemble, so we will use the long nanopore reads we have just cleaned to assemble the TB genome.</p>

        <p>Longer reads are beneficial to assembly techniques. They facilitate the closing of gaps in difficult to assemble regions, such as repetitive features. We will use <a href="https://github.com/fenderglass/Flye" target="_blank" style="color: #0881c2">flye</a>, a tool which specialises in long-read assemblies. </p>

        <img src="img/long_read_assemble.png" class="img-fluid" alt="Responsive image" style="max-width: 80%">

        <pre><code>flye --nano-hq ~/data/nanopore_activity_tb/qc/barcode08_reads.porechop.fastq.gz --out-dir out_barcode08 --threads 2</pre></code> 

        <p>Now that the assembly has completed, we will asses its contiguity using a tool caller quast </p>

        
        <br>
        <br>





























































































































    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="jquery-3.3.1.slim.min.js" crossorigin="anonymous"></script>
    <script src="popper.min.js"  crossorigin="anonymous"></script>
    <script src="bootstrap.min.js"  crossorigin="anonymous"></script>
    <script src="d3.v3.min.js"></script>
        <!-- Bootstrap popover -->
<script>
$('[data-toggle="popover"]').popover({
    boundary:'window',
    html: true,
  })
</script>
    <script>
        	$(function () {
          $('[data-toggle="tooltip"]').tooltip()
        })
	</script>
  </body>
</html>
