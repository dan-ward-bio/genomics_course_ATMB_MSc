


<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="course.css" type="text/css">

    <style>


    .jumbotron-head{
        background:linear-gradient(rgba(0, 0, 250, 0.15), rgba(125, 250, 250, 0.55)),url(img/ATMB_jumbo.jpeg);
        background-repeat: repeat-x;
        background-attachment: fixed;
        background-position: top right;
        color:black !important;
    }
	</style>


    <title>Third Generation Sequencing - A Case Study</title>
  </head>
  <body>
      <div class="jumbotron vertical-center jumbotron-fluid jumbotron-head">
        <div class="container">
          <h1 class="display-4">Nanopore Sequencing <br> Practical</h1>
          <p class="lead">An applied tutorial covering third generation sequence analysis</p>
        </div> <!-- Container -->
      </div>

      <div class="container">












        <!-- LSHTM PATHOGEN GENOMICS COURSE TO BE REMOVED!!!
        <div class="alert alert-warning">
          <b>
            Please run the following code to get the practical data:
          </b>
          <pre><code>bash <(curl -kSs https://tbdr.lshtm.ac.uk/static/get_nanopore_data.sh) </pre></code>
        </div>
       -->















	<h4>Nanopore Sequencing lecture</h4><br>
    <object data="presentations/Hello_I_am_page_1.pdf#page=1" type="application/pdf" width="100%" height="700px">
        <p><b>Example fallback content</b>: This browser does not support PDFs. Please download the PDF to view it:
        <a href="presentations/Hello_I_am_page_1.pdf">Download PDF</a>.</p>
    </object>
        <hr>
	<h4>Nanopore Sequencing Practical</h4><br>
      	<br>

        <h4>Introduction</h4>
        <p>In this session we are going to be looking at data generated by third-generation nanopore sequencing technology. Developed by Oxford Nanopore Technologies (ONT), these platforms, rather than the next-generation 'sequencing-by-synthesis approach', make use of an array of microscopic protein ‘pores’ set in in an electrically resistant membrane which guide strands of DNA or RNA through them. Each nanopore corresponds to its own electrode connected to a channel and sensor chip, which measures the electric current that flows through the nanopore. When a molecule passes through a nanopore, the current is disrupted to produce a characteristic ‘squiggle’. The squiggle is then decoded using basecalling algorithms to determine the DNA or RNA sequence in real time. Oxford Nanopore’s most popular platform is the MinION which is capable of generating single reads of up to <a href="https://ib.bioninja.com.au/_Media/genome-size-table_med.jpeg" target="_blank" style="color: #0881c2">2.3 Mb</a> (2.3 million bases).</p>

        <img src="img/sequencing_animation.gif" class="img-fluid" alt="Responsive image">

        <p> The MinION is one of 5 scalable platforms developed by ONT. High-throughput applications such as the GridION and PromethION use an array of nanopore flowcells to produce between 5 to 48 times more data than the MinION alone – outputting up to 48 TB of data in one run. More downscaled solutions such as The Flongle and SmidgION use a smaller, single flowcell to generate data. The MinION is a highly portable sequencing platform, about the size of a large USB flash drive. This technology enables researchers to perform sequencing analyses almost anywhere, providing they have the correct equipment to prepare the DNA libraries and analyse the output data. <p>

        <img src="img/picture_2.jpg" class="img-fluid" alt="Responsive image">

        <p>A complete sequencing run on the MinION platform can generate upwards to of 1TB of raw data, and downstream analyses require a significant amount of compute power – multicore high performance processors and large amounts of RAM. This poses a significant logistical challenge for researchers who want to take advantage of the platform’s portability aspect. Over recent years, the integration of <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit" target="_blank" style="color: #0881c2">GPUs</a> (graphics processing units) in to analysis workflows. <p>

        <img src="img/pipeline_diagram.png" class="img-fluid" alt="Responsive image">

        <h4>Activity Briefing</h4>
        <p>Today we will be working with the data your group generated in the Nanopore Sequencing practical. Each group sequenced three samples, wild type (W), DMSO (D) and rapamycin (R) treated lines. You have been given your respective groups' sample data in your virtual environment, ready for analysis. Today, we are going to take this raw data and generate some insights to help further understand your parasite lines. <br> In this session today, we will:<p>
            <ol type="1">
                <li>Basecall your data, transforming it from squiggle to bases.</li>
                <li>Perform quality control on the data, ensuring our data is of sufficient quality for analysis.</li>
                <li>Map the reads to a reference genome, producing three genomic alignment of our read sets.</li>
                <li>Perform variant calling on each of our alignments.</li>
                <li>Visualise the alignment and variant data in the IGV genome browser, to confirm insertion of a floxed PvDBP into the PkDBPα locus and successful DiCre-mediated excision of the floxed region. </li>
                <li>Produce coverage plots of each region, which will be used as a figure fro your manuscript report.</li>

              </ol>


              <br>
        <br>
        <h4>Basecalling</h4>

        <p>To convert the raw data output produced by the MinION sequencing run in to a usable form we need to perform a process called basecalling. This converts the raw electronic signal which is collected as the DNA passes through the pore, in to base reads – A, C, T or G. To do this we will use a program called Guppy – a software package designed by ONT which uses <a href="https://en.wikipedia.org/wiki/Recurrent_neural_network" target="_blank" style="color: #0881c2">recurrent neural nets (RNN)</a> to interpret the raw signal, which comes in a proprietary '.fast5' format file produced by the sequencer software and convert it in to the standard .fastq format, for use downstream in our pipeline. Users also have the choice of using the experimental <a href="https://github.com/nanoporetech/bonito" target="_blank" style="color: #0881c2">Bonito</a> basecaller which gives the option of training specialised models for specific basecalling applications. As mentioned above, GPUs are used to accelerate the basecalling process. Without a GPU performing basecalling becomes a very slow process, therfore it is advised that users procure a machine with a compatable Nvidia GPU <a href="https://esr-nz.github.io/gpu_basecalling_testing/gpu_benchmarking.html" target="_blank" style="color: #0881c2">(more information on this here)</a>. <p>

        <div class="row">
          <div class="col-sm">
             <img src="img/basecalling.gif" class="img-fluid" alt="Responsive image" style="width: 20vw">
          </div>

          <div class="col-sm">
            <img src="img/gpu_diagram.png" class="img-fluid" alt="Responsive image" style="width: 20vw">
          </div>
        </div>




        <p>Activate the relevant environment, navigate to the <i>~/data/ATMB/basecalling</i> folder in the home directory, and we’ll start the first step.<p>
        <p><b>IMPORTANT: Every time you open a new terminal window, you must re-activate the nanopore conda environment.</b>><p>

        <pre>conda activate nanopore</pre>

        <pre><code>cd ~/data/ATMB/basecalling/raw_fast5_reads/ </pre></code>

        <div class="alert alert-warning">
          <p>Use the <kbd>ls</kbd> command to see what is inside this folder. Use <kbd>head</kbd> to preview one of the <i>fast5</i> files. As you might find, it's completely unreadable. This is because at this stage, the data is in a binary format representing the <i>squiggle</i> signal we spoke about previously. We need to basecall this data before we can use it.</p>
        </div>

        <p> Basecalling can be performed in a number of ways. There is an option to perform this while sequencing in the <a href="https://nanoporetech.com/nanopore-sequencing-data-analysis" target="_blank" style="color: #0881c2">MinKNOW GUI package</a>, however this software provides fewer options in the ways basecalling can be completed and is less powerful. Here, we will use Guppy for maximum flexibility. Since the machines we are working on do not have a GPU available we will have to use the two CPU cores available to us. Therefore, we will only basecall a subset (<1%) of the dataset as an example, and in the subsequent steps we will use a pre-basecalled output</p>

        <p><strong>Hover over the different elements of the basecalling command to see its function. Copy the whole line in to the terminal and execute the command:</strong><p>


        <pre><code><a href="#" title="guppy_basecaller" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This is first command to call the main guppy executable.">guppy_basecaller</a> <a href="#" title="Basecalling configuration file" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This is the pre-trained model used for basecalling.<br><b>dna_r9.4.1_450bps_fast.cfg</b> is the model we will use in this case. However there are numerous models available depending on the flowcell used and the sequencing chemistry of the kit. <b>dna_r9.4.1</b> designates that we are using DNA basecalling with the R9.4 flowcell. <b>450bps</b> denotes the motor protein chemistry used for sequencing. This is unique to each kit used, so be sure to chose the correct one. <b>fast</b> denotes the complexity of the basecalling model to be used. The options are usually <b>fast</b>, <b>hac<b/> (high accuracy) or <b>sup</b> (super-high accuracy), the latter two of which are only suitable for machines with GPU resources.">--config dna_r9.4.1_450bps_fast.cfg</a> <a href="#" title="--trim_adapters" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller to automatically remove the sequencing adapter sequences.">--trim_adapters</a><a href="#" title="--trim_adapters" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller to search for the barcode sequences so that it can subset the reads."> --detect_barcodes</a> <a href="#" title="--compress_fastq " data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller to compress the outputted fastq files so that they consume less disk space.">--compress_fastq </a> <a href="#" title=">--input_path" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller where to find the raw fat5 files">--input_path ~/data/ATMB/basecalling/raw_fast5_reads </a> <a href="#" title="--save_path" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="This flag tells the basecaller where to save the compressed fastq output files">--save_path ~/data/ATMB/basecalling/fastq </a></code></pre>

        <div class="alert alert-warning">
          Hover over the basecalling model 'dna_r9.4.1_450bps_fast.cfg' in the above command to see an explanation. You can navigate to <kbd>/opt/ont/data</kbd> to see all of the models available for use. Alternatively, for simplicity, you can use the <kbd>--kit</kbd> and  <kbd>--flowcell</kbd> flags instead of defining a model. However, by default, using these arguments do not apply the most accurate basecalling models available.
        </div>


        <p> You should now see the bascalling process begin, and a progress bar appear. This may take some time depending on the performance of your machine.<p>

        <img src="img/basecall_1.png" class="img-fluid" alt="Responsive image">

        <p><strong>When the process in completed, you will find the basecalled reads in a .fastq formatted file. Navigate there by typing the following in to the terminal: </strong> <p>




        <pre><code>cd ~/data/ATMB/basecalling/fastq/pass</pre></code>

        <div class="alert alert-warning">
          <p>Use the <kbd>ls</kbd> command to see what is inside this folder. This directory holds the fastq formatted 'pass' reads  from the basecalling process. The reads have a quality score > 7. Use <kbd> <a href="#" title="zcat" data-toggle="popover" data-trigger="hover" data-placement="top" style="color:white" data-content="zcat is used in the same way as the cat command, except it is capabale of opening gzip compressed files">zcat</a> | head</kbd> to preview the compresssed <i>fastq</i> file. Unlike the fast5 files, these are human-readable and contain all of the read data required for downstream analyses. Can you identify any of the common elements of a .fastq format files - similar to the ones you may have encountered in previous sessions? Click <a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" style="color: #0881c2">here</a> to find out more about the FASTQ format.</p>
        </div>

        <br>

 <h4>Basecalling - Quality Control</h4>


        <p>Before moving on to the analysis steps, it is important to gauge the quality of your sequencing output. There are numerous factors which dictate the quality of the output data, spanning between quality of the input material, library preparation to software and hardware failure. We will look at some important metrics produced by the sequencer which will give us a feel for how well the run went.<p>

        <p>In order to get the run metrics in to a useful form, we will use an <a href="https://tleonardi.github.io/pycoQC/" target="_blank" style="color: #0881c2">pycoQC</a> to produce a range of plots in a HTML output, which we will use to judge the quality of the sequencing run. Something to note, is that in this activity we will only use a small subset of the sequenced reads, or else the analysis would take all day. This subsetting means that the sequencing telemetry may look inconsistent, when compared to a full run.<p>

       <pre><code>pycoQC -f ~/data/ATMB/basecalling/fastq/.sequencing_summary.txt -o ~/data/ATMB/basecalling/fastq/pycoqc_results.html</pre></code>

       <div class="alert alert-primary">
          After executing the command you should find a file called 'pycoqc_results.html'. Open them up in the file manager or in the terminal (with the below command) and inspect some of the plots and see what you can find out. As mentioned, the data here are only a small subset of reads, so some of the plots are incomplete. But this should give you a good idea of how this analysis should look.
        </div>

        <pre><code>firefox ~/data/ATMB/basecalling/fastq/pycoqc_results.html</pre></code>

        <p>Before continuing, quit firefox by clicking the X in the top right corner of the web-browser window.<p>


       <br>
        <h4>Question 1</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>Approximately how long did the sequencing run take?</strong></div>
          <div class="card-header" id="headingOne" data-toggle="collapse" data-target="#collapseOne">
                  5.9 hours
            </div>
            <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: You can find the answer in the <i>General run summary</i> table.
              </div>
            </div>
                <div class="card-header" id="headingTwo" data-toggle="collapse" data-target="#collapseTwo">
                  10.09 hours
            </div>
            <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>
        <br>

        <br>
        <h4>Question 2</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>What is the <a href="#" title="N50" data-toggle="popover" data-trigger="hover" data-placement="top"  data-content="N50 can be described as a weighted median statistic such that 50% of the entire assembly is contained in contigs or scaffolds equal to or larger than this value.">N50</a> of the <b>passed reads (>Q7)</b> for all basecalled reads in this run?</strong></div>
          <div class="card-header" id="headingThree" data-toggle="collapse" data-target="#collapseThree">
                N50= 9320 bp
            </div>
            <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
                <div class="card-header" id="headingFour" data-toggle="collapse" data-target="#collapseFour">
                 N50= 1309 bp
            </div>
            <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>Wrong. Try looking at the table at the top of the pycoQC report. Be sure to find the 'Passed' read section.</strong>
              </div>
            </div>
          </div>
        <br>
        <h4>Adapter Trimming</h4>

        <p>Nanopore library preparation results in the addition of a sequencing adapter at each end of the fragment. Both the template and complement strands to be sequenced carry the motor protein which means both strands are able to translocate the nanopore. For downstream analysis, it is important to remove these adapters. For this we will use <a href="https://github.com/rrwick/Porechop" target="_blank" style="color: #0881c2">Porechop</a>. This program processes all of the reads in our basecalled fastq file, and removes these adapter sequences. Furthermore, the ligation library prep process can result in conjoined reads, meaning an adapter will be found in the middle of an extra-long read. Porechop will identify these, split them and remove the adapters. In addition, if you use a multiplexing kit to maximise sample throughput, this program will split the reads based on the molecular barcode added to each sample. Our dataset only has one sample, so this demultiplexing won't be necessary. </p>
        <br>
        <p><strong>Let's launch porechop and remove the adapters from the basecalled fastq files. The RAP and DMSO files have already been done for you. First move up one directory, to where we have put the pre-basecalled files for you, then launch the command below that to run porechop on the WT dataset:</strong></p>
        <br>
        <pre><code>cd ~/data/ATMB/basecalling/fastq</pre></code>
        <pre><code>porechop -i ~/data/ATMB/basecalling/fastq/WT.fastq.gz -o WT.porechop.fastq</pre></code>

        <p><strong>Read the output of the terminal to understand better what porechop is doing to the dataset. Ask a demonstrator if you have any questions about this.</strong></p>
<br>
        <h4>Kraken QC</h4>

        <p>Another method of quality control is to check our reads for sequence contamination from other 'off-target' organisms. This is important in order to firstly, understand how effective your DNA extraction, enrichment and sequencing was. And secondly, to prevent anomalous reads from being incorporated in to assemblies.</p>
        <p>Using our basecalled reads we will perform an analysis using Kraken. Kraken is a tool which sifts through each read in a .fastq file and crosschecks it against a database of microorganism genomes. The output is a taxonomic assignment of each read, enabling to identify if any contamination has occurred. In this case we will be looking for any reads which do not belong to the <i>Plasmodium knowlesi</i> genome.</p>

        <p><strong>Let’s navigate to the kraken folder to begin the analysis:</strong></p>


        <pre><code>cd ~/data/ATMB/kraken</pre></code>

        <p>The following line of code is composed of these elements:<p>
        <p>Kraken – calling the Kraken executable<p>
        <p>kraken --db ~/data/ATMB/kraken/KDB/ - this points kraken to a vast sequence database of relevant microorganisms to cross-check our reads against<p>
        <p>--output temp.krak – this argument locates the output file<p>
        <p>WT.porechop.fastq.gz – this argument locates the input file
        </p>

        <p><strong>As before, to save time, we will run Kraken on only one sample. Type the following command in to the terminal to unleash the Kraken:</strong></s></p>

        <pre><code>kraken --db ~/data/ATMB/kraken/KDB/ --output temp.krak ~/data/ATMB/basecalling/fastq/WT.fastq.gz</pre></code>

        <img src="img/kraken_1.png" class="img-fluid" alt="Responsive image">



        <p>This file isn't particularly easy to interpret, so we will use a program called <a href="https://github.com/khyox/recentrifuge" target="_blank" style="color: #0881c2">Recentrifuge</a> to transform these data in to a more human-readable format.</p>

        <pre><code>rcf -k temp.krak -o kraken_output.rcf.html --nodespath ./taxdump</pre></code>

        <p>Try opening the HTML file generated by recentrifuge in a web browser, what can you tell about the sequencing run? Was is successful? Note - due to constraints with the virtual machine, we have generated an alternative report, which can be loaded using the below command. Copy and paste it in to the terminal. If you have any questions about this, ask a demonstrator.</p>

	<pre><code>firefox .kraken_output.rcf.html</pre></code>

        <div class="alert alert-primary">
          Can you see any contaminating reads? What is the majority <i>off target</i> organism, and why do you think it is present in our dataset?
        </div>

        <br>
        <h4>Question 3</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>Can you see any contaminating reads? What organism(s) is/are there?</strong></div>
          <div class="card-header" id="headingFive" data-toggle="collapse" data-target="#collapseFive">
                  <i>Dengue virus</i>
            </div>
            <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: Open up <i>temp.krak.rcf.full.html</i> in firefox and browse the results
              </div>
            </div>
                <div class="card-header" id="headingSix" data-toggle="collapse" data-target="#collapseSix">
                  <i>Homo sapiens</i>
            </div>
            <div id="collapseSix" class="collapse" aria-labelledby="headingSix" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done!
              </div>
            </div>
          </div>
        </div>
        <br>

        <h4>Mapping and Visualisation</h4>

        <p>Now that we have verified a successful sequencing run, our basecalled and trimmed Plasmodium-confirmed data are ready to go, we will now map the reads on to a reference genome and perform variant calling.</p>
        
        <div class="alert alert-warning">
        <p><b>Mapping tools are not to be confused with other sequence alignment tools, such as clustalO or MUSCLE. These are designed for a totally different use case and input data. Using these will not work on whole-genome read data.</b></p>
        </div>

        <p><strong>Move to the mapping directory:</strong></p>

        <pre><code>cd ~/data/ATMB/mapping</pre></code>


        <p>Now we can use minimap2 to align our QC completed, porechopped reads. Minimap2 is an alignment tool specifically designed to map error-prone nanopore reads. You might have used an alignment too previously, such a BWA. You can find more information about this tool by clicking the link <a href="https://lh3.github.io/2018/04/02/minimap2-and-the-future-of-bwa" target="_blank" style="color: #0881c2">comparing the two alignment tools</a></p>





        <pre><code>minimap2 -ax map-ont ~/data/ATMB/mapping/Pknowlesi_A1H1_WT_DiCre.fa ~/data/ATMB/basecalling/fastq/DMSO.porechop.fastq > DMSO_alignment.sam</pre></code>

        <br>

        <p>As before, we now need to convert our alignment .sam file in to a .bam formatted file:</p>

        <pre><code>samtools view -q 10 -b -S DMSO_alignment.sam > DMSO_alignment.bam</code></pre>

        <p>Next, we need to sort the .bam formatted file:</p>

        <pre><code>samtools sort DMSO_alignment.bam -o DMSO_sorted.bam</code></pre>

        <p>Finally we need to index the sorted bam file:</p>

        <pre><code>samtools index DMSO_sorted.bam</code></pre>

        <p><strong>Repeat each of the above mapping steps, from the first minimap2 command for the RAP and WT lines. Be sure to modify each command to have the correct input and output lines. </strong></p>

        <h4>Visualisation using IGV</h4>

        <p><strong>Now that we have successfully mapped the reads to a reference we can visualise them in IGV, to get a closer look at what our sequencing data looks like. We also add the GFF file for our genome. This contains all of the annotation metadata, such as gene names, coding regions etc. </strong></p>

        <p><strong>The Integrative Genomics Viewer (IGV) is a high-performance, easy-to-use, interactive tool for the visual exploration of genomic data. It is a staple for the bioinformatician when assessing genome alignments from whole genome sequencing data. </strong></p>

        <br>
        <br>
        <p>Open IGV from the terminal:
        </p>
        <pre><code>igv</code></pre>
        <br>
        <p>Go to the 'Genomes' dropdown at the top of the IGV window, load a genome from file, navigate to <b>/home/user/data/ATMB/mapping</b> by copying the bold text in to the 'File name' field and select <b>Pknowlesi_A1H1_WT_DiCre.fa</b>. <br> From the 'File' dropdown, open your sorted and indexed BAM file from the mapping steps by choosing 'Load from file', and navigate to the same mapping directory and choose, for example, 'DMSO_sorted.bam'. Finally, from the same directory and menu, open 'PknowlesiA1H1.gff'.
        </p>
        <div><img src="img/igv_open.png" class="img-fluid" alt="Responsive image"></div>
        <br>


        <p><strong>Now that you have loaded the reference genome, the BAM read alignment and the GFF annotation track, your IGV window should look a little bit like the image below. Explore the functions of IGV and browse the Pk A1H1 genome. </strong> </p>

        <br>

        <div><img src="img/igv_diagram.png" class="img-fluid" alt="Responsive image"></div>

        <div class="alert alert-primary">
            If you are curious how GFF annotations work, you can view the raw data by entering the below command in to a new terminal window. The <b>head -n 100</b> command will show the first 100 lines of content of a given filename in the terminal windoww, providing it is human readable text, and not binary or compressed data. To learn more about the GFF format, follow <a href="https://www.ensembl.org/info/website/upload/gff.html">this link</a>
          </div>

          <pre><code>head -n 100 ~/data/ATMB/mapping/PknowlesiA1H1.gff </code></pre>
        <br>

        <div class="alert alert-primary">
          An important aspect of an effective nanopore sequencing analysis is being able to differentiate between errors, caused by the inherent error-prone nature of nanopore sequencing, and true SNPs. Configure IGV to the maximum zoom on the read view (top right corder slider). You should see something similar to the image below. You can see that there are random errors dotted around the read panel like static on a TV. Do you notice that some positions in the alignment will have multiple SNPs in the same location. These are possibly the variants we are looking for, and the key to unlocking our sequence data. These columns represent positions which have a high frequency of basecalls which do not agree with the reference sequence. It is unlikely that random errors will appear in such a manner, and so, in our next analysis we will use a program to scan our alignment and identify these high frequency variants in a process called ‘variant calling’.
        </div>

        <br>
        <div><img src="img/igv_snp.png" class="img-fluid" alt="Responsive image"></div>
        <br>

        <p><b>Minimise the IGV window, leave open the terminal which launched it. Open a new terminal, activate the nanopore environment and move to the next steps.</b></p>


        <h4>Coverage, Depth and Variant Calling</h4>

        <br>

        <pre><code>conda activate nanopore</code></pre>
        
        <div class="alert alert-primary">
          Variant calling is a process used to identify new genotypes based on the ‘differences’ found our read data. In this case, we are going to be using the alignment you have just generated to compile a database of SNPs and indels, inferred from positions which have a majority allele which is different from the one found on the reference sequence.
        </div>


        <br>
        <p>
        Before starting on variant calling, we first need to do one more QC step. This analysis will tell us how well our reads have aligned to the reference and how comprehensive our sequencing run was. Two key metrics are required for this: reference coverage and read depth. Read coverage tells us the percentage of the reference which has had sequencing reads aligned to it, which allows us to identify any regions that may have not been successfully sequenced. Depth is an equally as important metric: it tells us how many different reads have mapped to the same position. This is a particularly important statistic if you intend on doing variant calling, as regions with low depth may fall prey to false calls due to the random errors we have in our nanopore data. With a high enough read depth, we can be fairly sure that these errors will be ignored. If you find this confusing, think of the alignment as a 2-dimentional plot. The X-axis is the length of the genome, this relates to coverage. The depth is the Y-axis, how deep the reads are at a given position.

        </p>

        <p><strong>
        Navigate to the ‘variant_calling’ folder and we’ll begin:
        </strong></p>

        <pre><code>cd ~/data/ATMB/variant_calling </code></pre>

        <p>We will use a variant caller called <a href="https://github.com/freebayes/freebayes">freebayes</a>. Freebayes is a Bayesian genetic variant detector designed to find small polymorphisms, specifically SNPs (single-nucleotide polymorphisms), indels (insertions and deletions), MNPs (multi-nucleotide polymorphisms), and complex events (composite insertion and substitution events) smaller than the length of a short-read sequencing alignment.</p>



        <pre><code>freebayes -f ~/data/ATMB/mapping/Pknowlesi_A1H1_WT_DiCre.fa ~/data/ATMB/mapping/DMSO_sorted.bam -F 0.5 -C 10 -r LT727654:329600-329932 -u  > DMSO_variants.vcf </code></pre>

        <br>
        <strong>-F</strong> – This command tells the program the location of the reference file, so the procram can compare the alignment against it inorder to make the calls.<br>

        <strong>-F </strong> – specifies the minimum frequency of a call. To eliminate errors, we set this to 0.5. That means that 50% of the reads have to agree with a particular alternative allele (variant)<br>

        <strong>-C</strong> – specifies the minimum read depth of a variant call. (More on this later)<br>

        <strong>-r </strong> – specifies the region in the genome to be called. We can not perform variant calling on the whole genome bacause it would take a very long time, and a more powerful computer.<br>


        <p>Once the variant callerhas finished, take a look inside the VCF file to see what kind of data it contains:</p>

        <pre><code>head -n 50 DMSO_variants.vcf </code></pre>

        <p>Check out <a href="https://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/#:~:text=VCF%20is%20a%20text%20file,a%20position%20in%20the%20genome.">this page</a> to unserstand the structure of a VCF file</p>

        <p>Go back to IGV and load the VCF in to the window by navigating to the variant_calling folder through the <b>File>Load from file</b> menu, and selecting DMSO_variants.vcf</p>

        <p>Navigate to the locus of the variant by copying <b>LT727654:329600-329632</b> in to the navigation form. You should see seomthing like that in the image below:</p>

        <div><img src="img/igv_vcf.png" class="img-fluid" alt="Responsive image"></div>


        <h4>Question 4</h4>
        <div class="accordion" id="accordionExample">
            <div class="card">
              <div class = "card-header alert-warning"><strong>Are the SNPs in a coding region? Check the GFF track. Zoom out to about 50% if you have any doubts.</strong></div>
          <div class="card-header" id="headingFive" data-toggle="collapse" data-target="#collapseFive">
                  <i>Yes. It's MSP1.</i>
            </div>
            <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-parent="#accordionExample">
              <div class="card-body alert-danger">
                <strong>False</strong>: Zoom out to 50% to see if you can notice another gene on the GFF track.
              </div>
            </div>
                <div class="card-header" id="headingSix" data-toggle="collapse" data-target="#collapseSix">
                  <i>No, it's not in a protein-coding region.</i>
            </div>
            <div id="collapseSix" class="collapse" aria-labelledby="headingSix" data-parent="#accordionExample">
              <div class="card-body alert-success">
                <strong>True</strong>: Right answer, well done! The closes gene is PKA1H_070011100.1.
              </div>
            </div>
          </div>
        </div>
        <br>

        <div class="alert alert-primary">
            Because we are working with a lab strain, there are likely few SNPs, as this reference is very closely related to the isolates we have sequenced. In future experiments however, it is very important to perform variant calling to identify possible genotypes that might confer drug resistance or SNPs that might be used for tracking transmission.
          </div>

        <h4>Validation of PvDBP insertion</h4>

        <p>Now load the other two BAMs you mapped in to IGV, using the same method you used to load the DMSO sample. Load the RAP.sorted.bam and the WT.sorted.bam files. Adjust the display ratios by dragging the partitions beteen the three BAM tracks and zoom out to 50% using the zoom slider in the top right corner. Have a look at the video below if you need help. </p>

        <video width="400" controls autoplay>
            <source src="./img/bam_track_sml.mov" type="video/mp4">
        </video>

        <p>In to the navigation form at the top of the IGV window, write <b>PKA1H_060029200</b>, this is a unique desegnation assigned to the Plasmodium knowlesi erythrocyte binding protein, the locus in the genome you have been working with throughout the module. You can find more information on this by visiting its <a herf="https://plasmodb.org/plasmo/app/record/gene/PKA1H_060029200">PlasmoDB</a> page.</p>
        

        







        <br>
        <br>
        <p>We need to use Samtools, a versatile package used in all facets of genomics, to extract the depth statistics from the .bam alignment file we generated in the previous section. This will generate a file called ‘depth_statistics’. Samtools will scan across the alignment counting how many reads have mapped to each base in the genome.</p>

        <pre><code>samtools depth ~/data/ATMB/mapping/DMSO_sorted.bam > depth_statistics</code></pre>

        <p>Take a look at the depth_statistics file using the <pre><code>head</code></pre> command.</p>



        <br>



        <div class="alert alert-primary">
          Now that we know the coverage and depth in the <b>depth_statistics</b> file, we can move on to the variant calling. For this, we will use a package called ‘bcftools’. Bcftools will look through the alignment and ‘call’ the positions in the alignment which do not agree with the reference, count them and compile them in to a database called a VCF. The  Enter the following code in to the terminal to begin the process:
        </div>

        <p>Next, we will use the R statistical package to generate a plot based on the data samtools generated. Simply type ‘R’ in to the terminal to initialise the R interface. </p>

        <pre><code>R</code></pre>

        <div><img src="img/depth.png" class="img-fluid" alt="Responsive image"></div>

        <p>Once you have initialised R, you can enter the following two lines of code, one after the other. The first command will load the ‘depth_statistics’ file, and the second will generate the plot</p>

        <pre><code>data<-read.table("depth_statistics")</code></pre>
        <pre><code>plot(data$V3,type="l",xlab="Reference Position", ylab="read Depth")</code></pre>

        <div class="alert alert-warning">
          Take a look at the plot you have just generated in R. Does the genome have adequate coverage and depth? What do you notice about the depth of the reads of nanopore generated data, as opposed to Illumina? Furthermore, why do you think there are these block-like increases and decreases in the depth? (Hint: how do you think these sequencing libraries were generated?)
        </div>


        <p>You can quit R by typing:</p>

        <pre><code>quit()</code></pre>























































































































    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="jquery-3.3.1.slim.min.js" crossorigin="anonymous"></script>
    <script src="popper.min.js"  crossorigin="anonymous"></script>
    <script src="bootstrap.min.js"  crossorigin="anonymous"></script>
    <script>
    $('[data-toggle="popover"]').popover({
        boundary:'window',
        html: true,
      })
    </script>
    <script src="d3.v3.min.js"></script>
    <script>
        	$(function () {
          $('[data-toggle="tooltip"]').tooltip()
        })
	</script>
  </body>
</html>
